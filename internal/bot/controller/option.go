package controller

import (
	"fmt"
	"github.com/Aoi-hosizora/ahlib-web/xtelebot"
	"github.com/Aoi-hosizora/ahlib/xstatus"
	"github.com/Aoi-hosizora/github-telebot/internal/bot/button"
	"github.com/Aoi-hosizora/github-telebot/internal/pkg/config"
	"github.com/Aoi-hosizora/github-telebot/internal/service/dao"
	"gopkg.in/tucnak/telebot.v2"
)

const (
	_ISSUE_ONLY_FOR_TOKEN           = "Send issue can only be allowed for users that bind with token."
	_ALLOW_ISSUE_Q                  = "Would you need to filter the message generated by yourself?"
	_ALLOW_ISSUE_FAILED             = "Failed to allow bot to send issue events periodically."
	_ALLOW_ISSUE_FILTER_SUCCESS     = "Success to allow bot to send issue events periodically (filter message generated by myself)."
	_ALLOW_ISSUE_NOT_FILTER_SUCCESS = "Success to allow bot to send issue events periodically (do not filter message generated by myself)."

	_DISALLOW_ISSUE_FAILED  = "Failed to disallow bot to send issue events periodically."
	_DISALLOW_ISSUE_SUCCESS = "Success to disallow bot to send issue events periodically."

	_SILENT_FAILED          = "Failed to enable silence send, please retry later."
	_SILENT_SUCCESS         = "Done. Now any sending will be done in silence."
	_DISABLE_SILENT_FAILED  = "Failed to disable silent, please retry later."
	_DISABLE_SILENT_SUCCESS = "Disable silent success. Any message will be sent directly now."

	_ENABLE_PREVIEW_FAILED   = "Failed to enable silence send, please retry later."
	_ENABLE_PREVIEW_SUCCESS  = "Done. Now silence send will be enabled when %s."
	_DISABLE_PREVIEW_FAILED  = "Failed to disable silent, please retry later."
	_DISABLE_PREVIEW_SUCCESS = "Disable silent success. Any message will be sent directly now."
)

// AllowIssue /allowissue
func AllowIssue(bw *xtelebot.BotWrapper, m *telebot.Message) {
	{
		chat, _ := dao.QueryChat(m.Chat.ID)
		if chat == nil {
			bw.RespondReply(m, false, _BIND_NOT_YET)
		} else if chat.Token == "" {
			bw.RespondReply(m, false, _ISSUE_ONLY_FOR_TOKEN)
		} else {
			bw.RespondReply(m, false, _ALLOW_ISSUE_Q, xtelebot.SetInlineKeyboard(xtelebot.InlineKeyboard(
				xtelebot.InlineRow{button.InlineBtnFilter, button.InlineBtnNotFilter},
				xtelebot.InlineRow{button.InlineBtnCancelSetupIssue},
			)))
		}
	}

	if !bw.IsHandled(button.InlineBtnFilter) {
		bw.HandleInlineButton(button.InlineBtnFilter, func(bw *xtelebot.BotWrapper, c *telebot.Callback) {
			bw.RespondDelete(c.Message)
			sts, err := dao.UpdateChatIssue(c.Message.Chat.ID, true, true)
			processOptionReply(bw, c.Message, sts, err, _ALLOW_ISSUE_FAILED, _ALLOW_ISSUE_FILTER_SUCCESS)
		})
	}
	if !bw.IsHandled(button.InlineBtnNotFilter) {
		bw.HandleInlineButton(button.InlineBtnNotFilter, func(bw *xtelebot.BotWrapper, c *telebot.Callback) {
			bw.RespondDelete(c.Message)
			sts, err := dao.UpdateChatIssue(c.Message.Chat.ID, true, false)
			processOptionReply(bw, c.Message, sts, err, _ALLOW_ISSUE_FAILED, _ALLOW_ISSUE_NOT_FILTER_SUCCESS)
		})
	}
	if !bw.IsHandled(button.InlineBtnCancelSetupIssue) {
		bw.HandleInlineButton(button.InlineBtnCancelSetupIssue, func(bw *xtelebot.BotWrapper, c *telebot.Callback) {
			bw.Bot().Edit(c.Message, fmt.Sprintf("%s (canceled)", c.Message.Text), xtelebot.RemoveInlineKeyboard())
		})
	}
}

// DisallowIssue /disallowissue
func DisallowIssue(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _BIND_NOT_YET)
	} else {
		sts, err := dao.UpdateChatIssue(m.Chat.ID, false, false)
		processOptionReply(bw, m, sts, err, _DISALLOW_ISSUE_FAILED, _DISALLOW_ISSUE_SUCCESS)
	}
}

// EnableSilent /enablesilent
func EnableSilent(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _BIND_NOT_YET)
	} else {
		sts, err := dao.UpdateChatSilent(m.Chat.ID, true)
		processOptionReply(bw, m, sts, err, _SILENT_FAILED, _SILENT_SUCCESS)
	}
}

// DisableSilent /disablesilent
func DisableSilent(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _BIND_NOT_YET)
	} else {
		sts, err := dao.UpdateChatSilent(m.Chat.ID, false)
		processOptionReply(bw, m, sts, err, _DISABLE_SILENT_FAILED, _DISABLE_SILENT_SUCCESS)
	}
}

// EnablePreview /enablepreview
func EnablePreview(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _BIND_NOT_YET)
	} else {
		sts, err := dao.UpdateChatPreview(m.Chat.ID, true)
		processOptionReply(bw, m, sts, err, _ENABLE_PREVIEW_FAILED, _ENABLE_PREVIEW_SUCCESS)
	}
}

// DisablePreview /disablepreview
func DisablePreview(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _BIND_NOT_YET)
	} else {
		sts, err := dao.UpdateChatPreview(m.Chat.ID, false)
		processOptionReply(bw, m, sts, err, _DISABLE_PREVIEW_FAILED, _DISABLE_PREVIEW_SUCCESS)
	}
}

func processOptionReply(bw *xtelebot.BotWrapper, m *telebot.Message, sts xstatus.DbStatus, err error, msgFailed, msgSuccess string) {
	flag := ""
	if sts == xstatus.DbNotFound {
		flag = _BIND_NOT_YET
	} else if sts == xstatus.DbFailed {
		flag = msgFailed
		if config.IsDebugMode() {
			flag += "\nErrorï¼š" + err.Error()
		}
	} else {
		flag = msgSuccess
	}
	bw.RespondReply(m, false, flag, xtelebot.RemoveInlineKeyboard())
}
