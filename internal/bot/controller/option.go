package controller

import (
	"fmt"
	"github.com/Aoi-hosizora/ahlib-web/xtelebot"
	"github.com/Aoi-hosizora/ahlib/xstatus"
	"github.com/Aoi-hosizora/github-telebot/internal/bot/button"
	"github.com/Aoi-hosizora/github-telebot/internal/pkg/config"
	"github.com/Aoi-hosizora/github-telebot/internal/service/dao"
	"gopkg.in/tucnak/telebot.v2"
)

const (
	_ISSUE_ONLY_FOR_TOKEN       = "Issue events sending is only be allowed for users that subscribe with token."
	_ALLOW_ISSUE_Q              = "Would you need to filter the issue events generated by yourself?"
	_ALLOW_ISSUE_FAILED         = "Oops. Failed to allow bot to notify new issue events periodically."
	_ALLOW_ISSUE_FILTER_SUCCESS = "Done. Now new issue events will be notified periodically (filter issue events generated by yourself)."
	_ALLOW_ISSUE_NOFILT_SUCCESS = "Done. Now new issue events will be notified periodically (do not filter issue events)."
	_DISALLOW_ISSUE_FAILED      = "Oops. Failed to disallow bot to notify new issue events periodically."
	_DISALLOW_ISSUE_SUCCESS     = "Done. Now new issue events will not be notified periodically."

	_SILENT_FAILED          = "Oops. Failed to enable silence send, please retry later."
	_SILENT_SUCCESS         = "Done. Now any message will be sent with no notification."
	_DISABLE_SILENT_FAILED  = "Oops. Failed to disable silence send, please retry later."
	_DISABLE_SILENT_SUCCESS = "Done. Now any message will be sent with notification."

	_ENABLE_PREVIEW_FAILED   = "Oops. Failed to enable link preview, please retry later."
	_ENABLE_PREVIEW_SUCCESS  = "Done. Now link in event message will have preview."
	_DISABLE_PREVIEW_FAILED  = "Oops. Failed to disable link preview, please retry later."
	_DISABLE_PREVIEW_SUCCESS = "Done. Now link in event message will have no preview."
)

// AllowIssue /allowissue
func AllowIssue(bw *xtelebot.BotWrapper, m *telebot.Message) {
	{
		chat, _ := dao.QueryChat(m.Chat.ID)
		if chat == nil {
			bw.RespondReply(m, false, _SUBSCRIBE_NOT_YET)
		} else if chat.Token == "" {
			bw.RespondReply(m, false, _ISSUE_ONLY_FOR_TOKEN)
		} else {
			bw.RespondReply(m, false, _ALLOW_ISSUE_Q, xtelebot.SetInlineKeyboard(xtelebot.InlineKeyboard(
				xtelebot.InlineRow{button.InlineBtnFilter, button.InlineBtnNotFilter},
				xtelebot.InlineRow{button.InlineBtnCancelSetupIssue},
			)))
		}
	}

	if !bw.IsHandled(button.InlineBtnFilter) {
		bw.HandleInlineButton(button.InlineBtnFilter, func(bw *xtelebot.BotWrapper, c *telebot.Callback) {
			bw.RespondDelete(c.Message)
			sts, err := dao.UpdateChatIssue(c.Message.Chat.ID, true, true)
			processOptionReply(bw, c.Message, sts, err, _ALLOW_ISSUE_FAILED, _ALLOW_ISSUE_FILTER_SUCCESS)
		})
	}
	if !bw.IsHandled(button.InlineBtnNotFilter) {
		bw.HandleInlineButton(button.InlineBtnNotFilter, func(bw *xtelebot.BotWrapper, c *telebot.Callback) {
			bw.RespondDelete(c.Message)
			sts, err := dao.UpdateChatIssue(c.Message.Chat.ID, true, false)
			processOptionReply(bw, c.Message, sts, err, _ALLOW_ISSUE_FAILED, _ALLOW_ISSUE_NOFILT_SUCCESS)
		})
	}
	if !bw.IsHandled(button.InlineBtnCancelSetupIssue) {
		bw.HandleInlineButton(button.InlineBtnCancelSetupIssue, func(bw *xtelebot.BotWrapper, c *telebot.Callback) {
			bw.RespondEdit(c.Message, fmt.Sprintf("%s (canceled)", c.Message.Text), xtelebot.RemoveInlineKeyboard())
			bw.RespondCallback(c, nil)
		})
	}
}

// DisallowIssue /disallowissue
func DisallowIssue(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _SUBSCRIBE_NOT_YET)
	} else {
		sts, err := dao.UpdateChatIssue(m.Chat.ID, false, false)
		processOptionReply(bw, m, sts, err, _DISALLOW_ISSUE_FAILED, _DISALLOW_ISSUE_SUCCESS)
	}
}

// EnableSilent /enablesilent
func EnableSilent(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _SUBSCRIBE_NOT_YET)
	} else {
		sts, err := dao.UpdateChatSilent(m.Chat.ID, true)
		processOptionReply(bw, m, sts, err, _SILENT_FAILED, _SILENT_SUCCESS)
	}
}

// DisableSilent /disablesilent
func DisableSilent(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _SUBSCRIBE_NOT_YET)
	} else {
		sts, err := dao.UpdateChatSilent(m.Chat.ID, false)
		processOptionReply(bw, m, sts, err, _DISABLE_SILENT_FAILED, _DISABLE_SILENT_SUCCESS)
	}
}

// EnablePreview /enablepreview
func EnablePreview(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _SUBSCRIBE_NOT_YET)
	} else {
		sts, err := dao.UpdateChatPreview(m.Chat.ID, true)
		processOptionReply(bw, m, sts, err, _ENABLE_PREVIEW_FAILED, _ENABLE_PREVIEW_SUCCESS)
	}
}

// DisablePreview /disablepreview
func DisablePreview(bw *xtelebot.BotWrapper, m *telebot.Message) {
	chat, _ := dao.QueryChat(m.Chat.ID)
	if chat == nil {
		bw.RespondReply(m, false, _SUBSCRIBE_NOT_YET)
	} else {
		sts, err := dao.UpdateChatPreview(m.Chat.ID, false)
		processOptionReply(bw, m, sts, err, _DISABLE_PREVIEW_FAILED, _DISABLE_PREVIEW_SUCCESS)
	}
}

func processOptionReply(bw *xtelebot.BotWrapper, m *telebot.Message, sts xstatus.DbStatus, err error, msgFailed, msgSuccess string) {
	flag := ""
	if sts == xstatus.DbNotFound {
		flag = _SUBSCRIBE_NOT_YET
	} else if sts == xstatus.DbFailed {
		flag = msgFailed
		if config.IsDebugMode() {
			flag += "\nErrorï¼š" + err.Error()
		}
	} else {
		flag = msgSuccess
	}
	bw.RespondReply(m, false, flag, xtelebot.RemoveInlineKeyboard())
}
